Restful Services



Tools:
Postman - https://www.getpostman.com/downloads/
Astra	- https://github.com/flipkart-incubator/astra
BurpSuitePro
OWASP Zaproxy
wfuzz


Important Commands:
curl -v -k --ssl-no-revoke -x 'http://127.0.0.1:8080' -H "Authorization: <uuid-pattern>" -H "Content-Type: application/json; charset=utf-8" -X POST 'https://api.webservice.dom/v2/path/to/endpoint' --data '{}'
	-Pipe (RESTful) API request to proxy


RESTful Servicce Description Languages & ENUMERATION:
Description Languages/Resource Listings:
WSDL
	(web service description language)
	enumeration:
	/path/to/name-of-service.wsdl
WADL
	(web application description language)
	enumeration:
	/path/to/name-of-service.wadl
Swagger
	-json-formatted
	/path/to/api/v1/name-of-service/swagger.json
	Swagger-Tools:
	https://www.getpostman.com/
	https://portswigger.net/bappstore/6bf7574b632847faaaa4eb5e42f1757c
	https://github.com/RhinoSecurityLabs/Swagger-EZ
	https://editor.swagger.io/
	(Conversion tools)
	https://apimatic.io/transformer
	https://openapi.tools/
iOS
	/.well-known/apple-app-site-association
XML Sitemaps
	/sitemap.xml
	/XMLSitemap
	/wp-includes/wlwmanifest.xml
	/XMLSchema
RSDL
	--RESTful Service Description Language
RAML
	--Restful API Modeling Languages
Apache Avaro
Barrister
Hypermedia
CloudRail
Google Cloud Endpoints
OData
	--Open Data Protocol
	--OASIS standard
	--Microsoft-developed
SERIN
	--Semantic Restful Interfaces
Hydra
	--Hydra Core Vocabulary
Standard
	/robots.txt
	/robots-dissallow.txt


>How are sessions authenticated and handled?
	*NOTE: Authentication is one of the most primary and in my experience commonly exploitable functions in RESTful APIs
	**which in no suggests the most common Authentication vulnerabilities are easy to exploit; though they should be easy to find instances of during source code review,
	**since most instances of insecure authentication are the result of non-cryptographic or weak cryptographic PRNGs and hashing algorithms (calls to standard libraries)
	**or in many cases dependant on easily reversible encodings (JWT, base64 obfuscation elsewhere) for secrecy
	authentication should be handled by a centralized IdP (Identity Provider); IdP issues authentication tokens
		-are issued tokens sufficiently complex and random?
			test for unpredictability
				-generate and collect many auth tokens, are there any noticeable patterns in generated tokens?
			-tool: Burp Sequencer
		is a pseudorandom number generator or hashing function used to generate token values?
			-pseudorandomly generated tokens:
				is a cryptographic pseudorandom number generation algorithm used?
					-vulnerabilties include backtracking (resistence) and prediction (resistance)
						--backtracking resistence: previously generated bits should be impossible to recover; prediction resistence: future bits should be impossible to predict
					check with statistical analysis
						-count the number of 1 bits versus the number of 0 bits OR the distribution of 8-bit patterns
							--measure of entropy
						--passing statistical analysis tests does not preclude cryptographic security
							--it is possible to design cryptographically insecure/weak PRNGs that will in most cases pass statistical analysis testing even with large sample sets
					to ensure normaly in the result set of auth tokens, compare them with a result set obtained for a reliable sample of equal size:
						> openssl rand <# bytes> --out outfile.ext
					Mersenne Twister (MT) is the most commonly implemented non-cryptographic PRNG, check against known MT patterns if generation seems weak/patterned
						--default PRNG for: C++ (in standard lib since C++11), C++ BOOST, PHP, Python, Ruby, R
						consists in an internal state (S) consisting of 624 32-bit words
						Ssub(k+624) = Ssub(k+397) ^ A((Ssub(k) & 0x80000000) | (Ssub(k+1) & 0x7fffffff))
							-*note: algorithm never combines two bits of S together, only operates on bits of S with constants & (bitwise AND) and | (bitwise OR)
							-ergo: any future state can be expressed as a bitwise XOR combination of bits from the the initation array state Ssub(1)...Ssub(624)
							--e.g. Ssub(228+624)=Ssub(882) can be expressed as a function of Ssub(625), Ssub(228) and Ssub(229), Ssub(625) by expression in terms of Ssub(398), Ssub(1) and Ssub(2)
							--ergo converse is subsequently true: bits fron the initial state cab be expressed as a an XOR of output bits
					-problem is linear insecurity, algorithm involves operation on only single bits, linear combinations of those bits include max 624 variables
					-non-linear algorithms also include products (&[AND]-combinations) of bits, which with some same seed allows for up to 2^264 variables
					--java.util.Random() and Math.random() in java standard libraries are also commonly used and insecure/weak
					types of cryptographically secure PRNGs (CSPRNG):
						stream cipher
						block cipher
						CSPRNGs by design, e.g. algorithms Yarrow-160 or its improved derivitive Fortuna
						combination PRNGs, combining several PRNG algorithm privimitives sufficient to remove the detectable non-randomness of each given primitive
			hashing function-derived algorithms
				check random-looking values for patterns matching cryptographic hashes
					-tool: https://github.com/psypanda/hashID
					-tool: https://code.google.com/archive/p/hash-identifier/
					does the parameter or context of the response body indicate what the format of the hash value may be?
						-can MASK a PRINCE rule be written to brute force the plaintext message given a hash value?
					does tampering with the hashed value return errors?
						-appending escape characters or sending invalid values (e.g. wrong length or charset for submitting where a hash is expected) return errors
					does the applications produce valid responses if hashed values replaced with arbitrary valid hash values computed by an attacker
						-are arbitrary values sent to the server within computed hash values processed by the server?
							-are those values stored in session variables, a filesystem (is stored data serialized?) or database?
							-will a message containing escape sequences that is computed to a hashed value be processed as a sequence escaping into operation?
								-SSTI?
								*any system doing this will depend upon a (likely relatively small) fixed number of pre-computed hashed message values
		-test for other paramater modifications to recieve session tokens without properly authenticating
	access control decision should be taken locally by REST endpoints
		can any requests be directly accessed?
				--do any of these constitute information disclosure vulnerabilties?
			prior to or without authentication?
			redirecting to an authentication page?
				does the resulting url for the authentication page contain an open redirect?
		-test for parameter modification if direct access is forbidden
	Is BASIC AUTH in use?
		APIs should support standard AUTH (JWT, OAUTH, &c)
	Deriving session identification from cookies or headers (or local/sessionStorage)
		What parts of the Session ID are static?
			What portions of the Session ID are static for replicated authentication conditions?
		What information can be deduced from the structure of the Session ID?
			What patterns are present in Session ID struture and/or within (possibly even between) derivative partial structures  
		What sensetive information is stored in the Session ID?
	Does the authentication function have a max retry limit?
		Is the there a strong ReCaptcha mechanism protecting against further attempts?
	Are multiple concurrent sessions allowed/possible?
>API Access Tokens
	Generating sufficiently many tokens in (as near simultaneously as possilbe) succession, how much entropy is measured in the generated tokens?
	Are there any noticeable patterns in the generated tokens by either examining successively (e.g. incrementation) or common patterns noticeable between tokens without examining them in sequential order?
		Examing the series of generated tokens converted to hexidecimal notation, are can any patterns be discerned in the same ways now? Can bitwise operations explain any patterns noticed in the plaintext?
		Most commonly discovered patterns:
			static string as (hyphen-seperated) segment (usually leading) segment of all keys
				--repeat process at different time if time or incrementation input 
			repeated sub-string in multiple tokens?
	What is the character set used to generate the access token?
		alphabetic? alphanumeric?
		case sensitive?
	Given key length, accounting for measured entropy and patterns discovered that reduce the complexity of generating likely valid (in use by another user) key; how many keys we would need to be generated and tested by making an api request to perform non-targeted impersonation as a brute force attack?
		Are there any other unique header fields, uri segments, or request body values the service application validates the api key, e.g. a user/organization/&c identifier, against on every endpoint?
		-prefer testing against "ping"/"status"/"online" key against endpoints for less intrusive and to recieve most immediate possible response
>JWT (JSON WEB TOKENS)
	-string composed by 3 parts separated by a "."
		header
			-JOSE header (JSON Object Signing and Encryption header)
			-metadata that describes which algorithm is used for signature and/or encryption
		payload
			-contains data that can be serialized to a JSON string
		signature
			-used to by server to ensure confidentiality and verify integrity of payload
	--each part can be encoded using base-64
		echo $jwtstring | base64 -d
	--can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA
		echo -n "value" | openssl dgst -sha256 -hmac "key"
	Unsecure JWT
		--not protected by a signature or MAC
			{"alg":"none"}
		-unsecured JWT are simple base64-encoded strings
		-can the signature or MAC be brute-forced?
		*signatures should be preferred over MACs for integrity protection
			--a random complicated key should be in use to make brute forcing a JWT resource-intensive
	Is the algorithm extracted from the payload?
		-If MACs are used for integrity protection, every service that is able to validate JWTs can also create new JWTs using the same key
			--ergo: all services using the same key have to mutually trust each other
			--ergo: compromise of any service also compromises all other services sharing the same key
		-algorithm should be forced on the backend (preferably HS256 or RS256)
		What algorithms are considered insecure?
			HMAC keys shorter than 256 bits
			AES keys shorter than 128 bits
			 RSA keys shorter than 1024 bits
	Does a relying party or token consumer validate JWT by verifying its integrity and claims contained
		--this is the most secure configuration
		-else may rely on the information of the JWT header to select the verification algorithm
			--this is an insecure configuration
	Standard Claims that should be verified:
		'iss' or issuer - is this a trusted issuer? Is it the expected owner of the signing key?
		'aud' or audience - is the relying party in the target audience for this JWT?
		'exp' or expiration time - is the current time before the end of the validity period of this token?
		'nbf' or not before time - is the current time after the start of the validity period of this token?
	Does a decoded JWT contain any information that should not be or is redundantly stored on the client system?
		Is this sensitive information?
		-only the server should know the "secret" that is used to generate the JWT
			--if data contained in JWT is modified, server should fail to decode it
	How long does the token live?
		-TTL or RTTL should be as short as possible
		tokens with long lifespans may allow csrf attacks or may be returned to an attacker in an xss payload
	Where is the JWT stored?
		-JWT stored in client browser LocalStorage can be returned via DOM interaction and is made especially vulnerable with weak CORS policies
	Can the JWT ever be sent over unecrpyted/plaintext HTTP?
		-an MitM and/or MitB attack forcing HTTP downgrade can trivially intercept token if sent over plaintext
		--unlike cookies, JWT cannot be flagged as 'http-only' or 'secure'
			--only limited to defined origin and attacks impeded by potential SOP violation
	Cracking 'secure' JWT tokens
		--what's needed to brute force?
		Token
			-HS256 JWT Token
		Alphabet
			-alphabet to use for brute force attempt
			--character array of all values to iterate over
			"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
		--expect 20-60mins to crack using high-end desktop (i9-9800X (Skylake-X architecture, 10core/20thread [3.5GHz])) complex high entropy token; 40-100mins using high-end laptop (i7-9850H (Coffee Lake-H architecture, 6core/12thread [2.6GHz])) CPU-based brute force
	-tool: https://github.com/lmammino/jwt-cracker
		--HS256 brute force cracking tool
		npm install --global jwt-cracker
		jwt-cracker <token> [<alphabet>] [<maxLength>]
		jwt-cracker "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ" "abcdefghijklmnopqrstuwxyz" 9
	-tool: https://github.com/lmammino/distributed-jwt-cracker
		npm i -g distributed-jwt-cracker
		jwt-cracker-server <jwtToken> [options]
		jwt-cracker-server 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ' -a="abcdefghijklmnopqrstuwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789" -p 4444 -P 5555 -b 5000000
			--start a new server
		jwt-cracker-client [options]
		jwt-cracker-client --host=3.124.41.213 --port=4444 --pubPort=5555
			--start a new client
	-tool: https://github.com/mike-engel/jwt-cli
	-tool, gui, html: https://github.com/ticarpi/jwt_tool
	-tool, burp extension: https://github.com/mvetsch/JWT4B
	-tool, burp extension: https://github.com/pinnace/burp-jwt-fuzzhelper-extension
>OAUTH
	Is redirect_uri validated on the server-side?
		-only whitelisted URLs should validate
		Can the IP be spoofed using an arbitrary X-Forwarded-For: Header value?
		OAUTH open redirect example exploit:
			http://target.dom/endpoint?redir=http://attacker.dom/target.dom
	Does OAUTH exchange for code or token?
		-always prefer code over tokens
			--don't allow response_type=token
	Is the state parameter used with a random hash on the OAuth authentication process?
		-else CSRF attacks may be possible
	Are the default scope and validate scope parameters defined for each application?
	Replay attacks?
	Session fixation?
	XML Signature wrapping?
>SSO
	--single sign on
	
>API Keys
	Is the API key required for every request to each protected endpoint?
	Is HTTP response code 429 "Too Many Requests" ever returned while rapidly making requests?
	Is an API key revocation functionality in place?
		-does it strictly comply with application's usage agreement?
>Privilege Escalation (vertical or horizontal)
	Can other users be enumerated?
		How many requests would be required to discover the identity of an arbitrary target or all users?
		Possible Methods:
			Query a list/table/collection/(other representation of an array) of users
				Can a full index of users be returned?
					-Wildcard Injection
						*--wildcard characters or phrases may or may not require precession by an escape sequence, subquery encapsulation, (non-)particular sorting function phrase(s) or additional comparison operation AND/OR succession by an endline character, comment invocation, sequence unescape, subquery endcap, sorting phrase adjective or comparison operation (either conjoining with a preceding referenced value given some new equivelancy relation or being disjoined by resolving a false equivelance/equality via an injected identifier, e.g. rendering identifiers in an injected statement falesly equivelant values by expecting all to be cast as types for which comparison can be evaluated)
						SQL: * (SELECT statement injection), % (LIKE statement injection; matches 1+ character), _ (LIKE statement injection; matches exactly 1 character)
						MongoDB: *, /.*/ (JavaScript regex), {'$regex': ''} (regex typedef), { $ne: 1 } (resolves to JavaScript null type, evalutes as declared uninitialized value), {$exists:true}, {$exists:false}
				Can any indexed data other than the queried user identifier (username, email) be queried?
					Can any of the queried attributes be iterated over for each unique user?
				Can bulk user information returned in a single object, does it need to paginated over or can unique queries be requested serially for ordered values following the final value in the series included in a most recent previous response?
					If all possible values are queried, should all indexed items be expected to be returned in at least 1 response?
						Iterating over all possible queries:
						e.g.:
							crunch 4 13 mixalpha-numeric-all-space -o word.lst \
							for i in `cat word.lst`; do curl -X POST https://api.target.dom/v2/search --data '{ "querystring": \"$i\" }' | awk -f json-parse.awk - >> /tmp/placehold && sort -u /tmp/placeholder -o /tmp/placeholder ; done
						--results must be ordered (non-pseudo-random)
							--test by making same request at multiple different time intervals
						--sufficiently many results must be returned or be capable of being paginated over in qeury requests for each unique possible query
							--not measurable without knowing length of index
			Registration page harvesting:
				On parameter submission, either asynchronously or form data submission request body, are any expected unique user attributes (e.g. username, email address, phone number, &c) declared unavailable (not unique) in the response body?
					Do errors caused by parameter validaty and uniqueness return identical responses (Status Code & Response Body)?
						In which order does the API evaluate (assuming accorded response) validity and uniqueness?
							If validity is evaluated prior to uniqueness actually creating accounts may be required to test if a username is in use.
				Does the registration function require multiple steps to complete?
					Does it require making requests to (an) endpoint(s) or accross multiple pages or screens?
						If so validation and parameter unicity are in most cases capable of being tested without creating any new accounts.
			Login page harvesting:
				Does login failure return an error message or response?
					Does the returned login attempt message or response body indicate distinctly whether the username is valid (for an existing account)?
				Are the there protections against many authentication attempts?
					account lockout
						are email warnings sent?
							are the likely to be caught by spam filters? 
						time-based or requiring some user interaction?
					ip address ban (usually temporary)
						--perform test using clustered instances on cloud-hosting services
					client-side controls
						check cookies, parameter values, DOM object values
			Unique user endpoint harvesing:
				where is the unique identifier located?
					uri segment
					uri parameter
					request body parameter
					subdomain name
				what type of unique identifier is the target field?
					username/orgname
					email
					uuid
					account number (incremented)
>SSL
	Is the application also hosted as plaintext?
	Is the HSTS header sent in HTTP responses?
	Is certificate-pinning enabled for the FQDN?
>Application Templating Engine
	
>IDOR
	(Insecure Direct Object Reference)
	*common to find endpoints that don't perform authorization checks that should
		e.g. /something/api/v1/service_name/users/666/
		*GET Requests may allow access to sensetive user information
		*POST requests are more likely to allow manipulating user information
	-out of range index errors are fairly common given a an integer value
		--e.g. /path/to/endpoint/666 where index item 666 is uninitialized, thus Null
		--may return verbose respones containing source code or revealing backend framework, data storage system, &c
>Rate Limiting
	-HTTP status code for rate limiting defined as 429 by RFC 6585
		-RFC 6584 reappropriates 503 Status Code header 'Retry-After:' for use with 429 Responses
		Other common indications that an API rate limit has been hit:
			Legacy Status Response Code 420
				--still implemented in pre-standardization APIs and ocassionally in newly written APIs
				--originally used by twitter API with response “420 - Enhance Your Calm”; some engineers really liked that joke and don't want it to die
			Status Response Code 403 combined with an error code
				--Google API services and Github v3 API (distinct from the newer GraphQL API) use status code 403 Forbidden for rate limiting and include JSON message bodies
				--Google and Github host additional external APIs and other (services/libraries) remain modeled after them, check the response body of 403 Responses when querying an API
					--rarely will APIs have a mechanism for forbidden file access as a response, because they generally do not serve files from a webroot
			Rate limit responses may be included in API headers, e.g.:
				X-RateLimit-Limit:
				X-RateLimit-Remaining:
				X-RateLimit-Reset:
	How have you been rate-limited?
		-APIs most commonly use one or both of two factors determining when an API rate limit has been reached:
			API Key/AUTH Key
				--especially true of premium/paid APIs
				x-trivially bypassed for freely-accessed APIs if multiple API Key-generating accounts can be created
					--may require multiple contact address accounts or in some cases even multiple domain names
			IP Address
				--especially true of APIs that do not require user authentication
				x-trivially bypassed clustering cloud-hosting service instances to make additional requests originating from
		--For responses indicating a 'Retry', 'Reset' or similar header or body response in Unix Epoch Time(UTC) (or any datetime format that can be converted to an int value) a shared key, e.g. in Redis, tracking request availability time or set with an expiry period may be the most efficient method to stagger programmatic or daemonized requests in accordance with expected or agreed service usage terms.
			--Test that sleep does not block background processes from processing other jobs
			--can happen in languages where sleep sleeps the whole process and that process is running multiple types job on the same thread
	Where have you been rate-limited?
		Is the entire API rate-limited or are only endpoints within certain paths?
			--NGINX rate-limiting configured by two main directives:
				limit_req
					--counts universally
				limit_req_zone
					--counts within location for defined virtualhosted service
			Do Paths share rate limits or are limits counted exclusive to a path?
				--NGINX limit_req_zone applies only within singular zone configuration, e.g.:
					limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;
					server {
						location /path/ {
							limit_req zone=alimit;
				

		
		


Best Practices:
Prefer to scan/fuzz item update/modification requests rather than creation requests



Appendix 1:
Common Languages/Libraries used to implement APIs
	node.js
		ExpressJS
		Electron
		node-restify
		Sails.js
	Python
		Flask
			flask-restful
			flask-restless
			Flask-Potion
		Django
			Django-REST-Framework
			django-tastypie
		Bottle
		Cherrypy
		Twisted
		webpy
		restless
	Java
		Scala
			Akka
		Glassfish
			Jersey
		Netty
			Wildfly
				--formerly JBoss Application Server
			RestExpress
	PHP
		Symphony2
		Laravel
		Slim
		Microrest
	Ruby
		Rails
		Sinatra
		Grape
	ASP.NET
		Nancy
	Go
		gocrud
		go-rest
			go-json-rest
		sleepy
Web Server API Management gateways (API Gateways):
NGINX
	OpenResty
		--NGINX+Lua
	Kong
		--Scalable, distributed, and plugin oriented API gateway on NGINX backend
	Tyk
		--Lightweight API gateway with analytics logging
		--written in Go
Express Gateway
	--Microservices API Gateway built on ExpressJS
Node Server
	--server.js