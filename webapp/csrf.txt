CROSS-SITE REQUEST FORGERY



##**Note: Preface - first assumption, simply because CSRF protections exist does not entail that a page is not vulnerable to attack
##			further, even well-implemneted CSRF protections are vulnerable to brute force attacks and credential spraying
##*CSRF vulns are common and EASY to exploit in most cases 

Goals:
	permission spoofing/capturing
	disrupt normal site activity
	
Requirements
	slave must have session/cookie
	slave must be identified by network protocol(HTTP Auth)
	

Types of CSRF Tokens
	tagged into response body and must be returned (via Element as a DOM object) to a future request
		--basic referer check
	arbitrary header value
	cookies as tokens

Universal CSRF Bypass
	UI Redress
		"clickjacking"
		-UI Redress on an endpoint bypasses all CSRF protection on that endpoint

Common Implementation Vulnerabilities:
	Accepts multiple requests methods
		--e.g. a valid request parsed as either POST or GET is significantly less likely require CSRF Token validation as a GET request than a POST request, or may contain a valid CSRF token in the failed request response, reseeding the value to attach to a concurrent request
		--most common in PHP applicaitons due to superglobal parsing, but may be found in applications written in other languages, as well
	Ignore Token Parameter
		-some applications will only validate CSRF tokens passed to it and will bypass validation checks if a CSRF token is not included in a given request
	Tokens are not session-specific
		--various methods, at different levels of an application (or even level-agnostic pending the language/framework), of verification may be implemented to validate tokens, depending on variable scope, tokens valid for entire lengths of a session (which may be very long, especially true if token is stored as a cookie) or rarely simply checking that a token matches the parameters of a token the applications' token-generation algorithm
			--may create a situation where a CSRF PoC needs only an attacker-seeded cookie, any random cookie generated by a known algorithm, any cookie generated by a known algorithm with one or more predictable seed value (e.g. datetime) or by gathering a cookie via xmlhttp request to populate a concurrent malicious CSRF request on the users' behalf from the same endpoint hosting a CSRF PoC
	


FINDING CSRF TOKENS QUICKLY
curl -s -b "PHPSESSID=$PHPSESSID" -b jar.cookie "https://target.dom/endpoint >en.html
curl -s -b "PHPSESSID=$PHPSESSID" -b jar.cookie "https://target.dom/endpoint >token.html
diff {tok,}en.html | grep "<input type='hidden'"


TIMING CHECKS
for x in {1..3}; do
  time curl -s -b 'PHPSESSID=$PHPSESSID' -b jat.cookie 'https://target.dom/endpoint?usr=uname&pword=pass&login=True' > /dev/null
done


BurpSuite
	Macro
Options -> Sessions -> Session Handling Rules -> Add
>Rule Description:CRSF_Handle -> Rule Action -> Add -> Run a macro
>Select macro -> Add
>Macro Recorder -> (Select) /endpoint/login
>Macro Description:Get CRSF_Token
>1 ->& Configure Item (top right button)
>Custom parameters locations in response -> Add
>>Parameter name: CRSF_Token
>>Start after expression: CSRF_Token' value='
>>End at delimter: ' />
>Enable: Tolerate URL mismatch when matching parameters (use for URL-agnostic CSRF tokens)
>Scope -> Tool Scope -> <Choices always were a problem for you>
>URL Scope -> Use Suite scope [defined in Target tab]
