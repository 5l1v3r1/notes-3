CROSS-SITE REQUEST FORGERY



##**Note: Preface - first assumption, simply because CSRF protections exist does not entail that a page is not vulnerable to attack
##			further, even well-implemneted CSRF protections are vulnerable to brute force attacks and credential spraying
##*CSRF vulns are common and EASY to exploit in most cases 

Goals:
	permission spoofing/capturing
	disrupt normal site activity
	
Requirements
	slave must have session/cookie
	slave must be identified by network protocol(HTTP Auth)
	

Types of CSRF Tokens
	tagged into response body and must be returned (via Element as a DOM object) to a future request
		--basic referer check
	arbitrary header value
	cookies as tokens

Universal CSRF Bypass
	UI Redress
		"clickjacking"
		-UI Redress on an endpoint bypasses all CSRF protection on that endpoint

Common Implementation Vulnerabilities:
	Accepts multiple requests methods
		--e.g. a valid request parsed as either POST or GET is significantly less likely require CSRF Token validation as a GET request than a POST request, or may contain a valid CSRF token in the failed request response, reseeding the value to attach to a concurrent request
		--most common in PHP applicaitons due to superglobal parsing, but may be found in applications written in other languages, as well
		--GET request URI may be retrieved to store as DOM object in PoC or otherwise reflected within accessible client browser SOP Origin pending CSP, e.g. reflect request back to referer or an origin with a frameable endpoint, from which a second arbitrary request may be induced
	Ignore Token Parameter
		-some applications will only validate CSRF tokens passed to it and will bypass validation checks if a CSRF token is not included in a given request
	Tokens are not session-specific
		--various methods, at different levels of an application (or even level-agnostic pending the language/framework), of verification may be implemented to validate tokens, depending on variable scope, tokens valid for entire lengths of a session (which may be very long, especially true if token is stored as a cookie) or rarely simply checking that a token matches the parameters of a token the applications' token-generation algorithm
			--may create a situation where a CSRF PoC needs only an attacker-seeded cookie, any random cookie generated by a known algorithm, any cookie generated by a known algorithm with one or more predictable seed value (e.g. datetime) or by gathering a cookie via xmlhttp request to populate a concurrent malicious CSRF request on the users' behalf from the same endpoint hosting a CSRF PoC
	Referer header checked instead of unique token:
		--usually implemented using Regex whitelist for compatability with target application subdomains and subdirectory pages
				--subdomains more likely to be accepted as whitelisting often only accepts valid domain names preceding "/" delimited as part of regex verification
				--but implemented using the same logic, especially if 3xx are differentiated from 2xx requests, a regex expecting . or www. my be bypassed by naming the URI endpoint hosting CSRF PoC a (valid) FQDN of the target host's domain, or even one of target host's ownership organization's domain's 
			--check if target application accepts its domain name in referer URL as subdomain or directory
			--e.g.	target.dom.pwn.dom
					pwn.dom/.target.dom
					pwn.dom/www.target.dom
		--application may only validate Referer if value is set, add '<meta name=”referrer” content=”no-referrer”>' to CSRF PoC as an html header
		

Chained attacks:
Session Fixation
	double-submit cookie
		-request contains same random token both as cookie and request parameter; server checks if values are equal
			--common implementation error that token is not stored for validation server-side, instead client token is checked again duplicate (and possibly valid format)
		--2-stop PoC:
			1.)induce target brower to write arbitrary value to cookie (session fixation)
			2.)forge cross-site request with same arbitrary value stored in client cookie

	


FINDING CSRF TOKENS QUICKLY
curl -s -b "PHPSESSID=$PHPSESSID" -b jar.cookie "https://target.dom/endpoint >en.html
curl -s -b "PHPSESSID=$PHPSESSID" -b jar.cookie "https://target.dom/endpoint >token.html
diff {tok,}en.html | grep "<input type='hidden'"


TIMING CHECKS
for x in {1..3}; do
  time curl -s -b 'PHPSESSID=$PHPSESSID' -b jat.cookie 'https://target.dom/endpoint?usr=uname&pword=pass&login=True' > /dev/null
done


BurpSuite
	Macro
Options -> Sessions -> Session Handling Rules -> Add
>Rule Description:CRSF_Handle -> Rule Action -> Add -> Run a macro
>Select macro -> Add
>Macro Recorder -> (Select) /endpoint/login
>Macro Description:Get CRSF_Token
>1 ->& Configure Item (top right button)
>Custom parameters locations in response -> Add
>>Parameter name: CRSF_Token
>>Start after expression: CSRF_Token' value='
>>End at delimter: ' />
>Enable: Tolerate URL mismatch when matching parameters (use for URL-agnostic CSRF tokens)
>Scope -> Tool Scope -> <Choices always were a problem for you>
>URL Scope -> Use Suite scope [defined in Target tab]
