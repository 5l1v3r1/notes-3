WINDBG

.help
.hh
.chain
	-Lists all loaded debugger extensions
.attach <PID>
.detach
q
.restart
x *!
	-list all modules
x ntdll!*
	-list all symbols of ntdll
x /t /v MyDll!*
	-list all symbol in MyDll with data type, symbol type and size
x kernel32!*LoadLib*
	-list all symbols in kernel32 that contain the word LoadLib
.sympath+ C:\MoreSymbols
	-add symbols from C:\MoreSymbols (folder location)
.reload /f @"ntdll.dll"
	-Immediately reload symbols for ntdll.dll.
.reload /f @"C:\WINNT\System32\verifier.dll"
	-Reload symbols for verifier. Use the given path.
l
	-toggle line numbers
g
	-go
!analyze
	-Display information about the current exception or bug check
!analyze -v
	-Analyzes the thread stack to determine whether any threads are blocking other threads
lm
	-list loaded modules
!lmi ModuleName
	-display information about a loaded module
~
	-list threads
!error ErrValue 1
	-Decode and display information about an error value
bl
	-list breakpoints
bp [Addr]
	-Set breakpoint at address 
r
	-dump all registers
d*
	-display memory
!heap
.process_info - display security related information of current process
	
	
	
BYAKUGAN
!load byakugan
!load byakugan.dll
!byakugan
	--help
!jutsu help
	-buffer handling
!jutsu <command> <args>
!jutsu identBuf <bufType> <bufname> <VALUE> <size>
	-e.g.
	ASCII
	!jutsu identBuf ascii myAsciiBuf CatImAKittyCatAndIDanceDanceDance
	MSFPattern
	!jutsu identBuf msfpattern myMsfPattern 16
	File
	!jutsu identBuf file myFileBuf C:\msf3\input.bin 64
!jutsu listBuf
	-List registered buffers
!jutsu rmBuf <name>
	-Remove registered buffers
!jutsu hunt
	--use after crash
	1. What buffer caused a crash
	2. What registers you've overwritten (and if pattern, at what offset)
	3. What registers point at what buffers
	4. What corruption has occured (toupper, tolower, etc)
!jutsu findReturn
	-find valid return addresses
	1. hunt will use all knowledge about controlled registers and buffer offsets to find all possible usable return addresses
!jutsu searchOpcode
	find opcodes in executable memory
	1. delimit instructions with pipes
		--e.g.
		!jutsu searchOpcode  pop ecx | pop ecx | ret
!jutsu searchVtptr
	-find ptr -> ptr - x -> ptr -> opcodes
	--like searchOpcode, except with the second ptr offset as the first argument
	--e.g.
	!jutsu searchVtptr 4  add esp, 0x14 | ret
!jutsu trackVal
	-find and primitive values in memory
	
	
!tenketsu help
	-heap handling
!tenketsu log <logname.xml>
	--load heap logging
!tenketsu model
	-Load tenketsu heap modeling
!tenketsu listHeaps
	-list heaps when process is broken
!tenketsu listChunks <heap base>
	-display chunks

!pattern_offset <length> <optional: addr>

!mushishi <detect|defeat>
	-Anti-debugging detection/removal
!mushishi detect - detects several methods
!mushishi defeat - defeats known defeatable methods

!symport moduleName mapFilePath
	-Import IDA map files into windbg
	--e.g.
	!symport calc C:\Users\lgrenier\calc.map

	
PYKD
	-!MONA
	https://github.com/corelan/windbglib.git
.load pykd.pyd
	-load into memory
!py mona
!py mona help
	-get help


REFERENCES
https://www.corelan.be/index.php/2009/09/05/exploit-writing-tutorial-part-5-how-debugger-modules-plugins-can-speed-up-basic-exploit-development/
