INSTRUCTION		HEX		DESC
int	0x80		CD80; system/kernel call(e.g. to /bin/sh)
int	3			CC	; debugging trap
mov eax,1			; system call number (sys_exit)

section	.text		fixed memory segment defines are in memory that stores instruction codes
	global_start	;required declaration for linker(e.g. gcc)

_start:


section	.data		static memory segment to declare memory region where data elements are stored for the program


section	.bss		static memory segment cpntaines buffers for data to be declared later in the program, buffer memory is zero-filled


INSTRUCTIONS
	DATA MOVEMENT INSTRUCTIONS
MOV		<reg,mem>,	<reg,mem,const>
MOV		DST,	SRC ;
PUSH	<reg32,mem,con32>
PUSH	ebx			;push ebx onto the stack -decrements ebx by 4 then places its operand into location(or register) at [ebx]
PUSH	[var]		;push the 4 bytes at address var onto the stack
POP		<reg32,mem>
POP		edi			;removes top 4-byte element from the stack then places it into operand(register or memory location) edi
POP		[ebx]		;pop top element from stack into memory at 4 bytes starting at location ebx
LEA		<reg32>,	<mem>
LEA		edi,	[var];places address specified (pointed to) by right operand into register specified by first operand 
CONTROL FLOW
LABEL	:<label>
CMP		<REG>,<REG,MEM,CON>
CMP		<MEM>,<REG,CON>
JMP		<label>
JE		<label>
JNE		<label>
JG		<label>
JGE		<label>
JL		<label>
JLE		<label>
JA
JNA
JNAE
JAE
JB
JBE
JNB
JNBE
JZ		<label>
JNZ		<label>
JXCZ
JC
JNC
JO
JNO
JNP
JP
JPE
JPO
JS
JNS
CALL	<label>
RET
	LOGICAL
AND		<REG>,<REG,MEM,CON>
AND		<MEM>,<REG,CON>
AND		BL,		0FH	;BITWISE AND sets BL as equal to only binary values set for both BL and 0FH(1111)
OR		<REG>,<REG,MEM,CON>
OR		<MEM>,<REG,CON>
OR		BL,		0FH ;BITWISE OR set BL as equal to all binary values set for either both BL or 0FH
XOR		<REG>,<REG,MEM,CON>
XOR		<MEM>,<REG,CON>
XOR		BL,		0FH ;sets BL resultant bits to 1 if and only if operands different
TEST	BL,		0FH ;like AND, but does not set BL
NOT		<REG,MEM>
NOT		BL			;reverses bits in an operand, sets unset bits and unsets set bits
<REG32>	EQU	<VAR,MEM,CON>
<REG32>	EQU	<VAR,CON>
	ARITHMETIC
INC		<REG,MEM>
DEC		<REG,MEM>
ADD		<REG>,<REG,MEM,CON>
ADD		<MEM>,<REG,CON>
SUB		<REG>,<REG,MEM,CON>
SUB		<MEM>,<REG,CON>
MULT
IMUL	<REG32,MEM>,<REG32,MEM>
IMUL	<REG32>,<REG32,MEM>,<CON>
DIV	<REG32,MEM>,<REG32,MEM>
IDIV	<REG32>,<REG32,MEM>,<CON>
NEG		<REG,MEM>
SHL		<REG,MEM>,	<CON8,CL>
SHR		<REG,MEM>,	<CON8,CL>
	VARIABLE DECLARATION INSTRUCTIONS
bool		DB	'Y'			;
byte		DB	100			;a byte value is defined
bytetable	DB	100, 300	;a table of bytes is defined
hexnum		DW	12345		;
word		DW  300			;a word value is defined
wordtable	DW  100, 300	;a table of words is defined
number		DD	12345678	;Double Word
number		DQ				;Quadruple Word
number		DT				;Ten word Word
MOV CL, bytetable[2]		;gets 3rd element of the BYTE_TABLE
wordtable TIMES 10 DW 0		;allocates 10 words (2 bytes) each initialized to 0
RESB
RESW
RESD
RESQ
REST
	Type OPERATIONS
INST	BYTE	WORD	DWORD
MOVS	MOVSB	MOVSW	MOVSD
LODS
STOS
CMPS
SCAS